# 8.

如果今天 SQL 想要依照不同情況解開不同的查詢條件，讀入SQL 檔案是比較快的。


```
|--com.example.demospringboot
   |--DemospringbootApplication.java
|--com.example.demospringboot.configuration
   |--SwaggerConfig.java
   |--RestConfiguration.java
|--com.example.demospringboot.controller
   |--TestController.java
   |--ProductController.java
   |--EmpController.java // 修改的檔案
|--com.example.demospringboot.entity
   |--Car.java
   |--CarPK.java
|--com.example.demospringboot.model
   |--Product.java
|--com.example.demospringboot.repository
   |--CarRepository.java
|--com.example.demospringboot.service
   |--CarService.java
   |--ProductService.java
|--com.example.demospringboot.service.impl
   |--CarServiceImpl.java
   |--ProductServiceImpl.java
|--com.example.demospringboot.service.sql
   |--SqlAction.java // 修改的檔案
```

```java
// SqlUtils @Component
/**
     * 取得查詢SQL
     * @param sqlName
     * @throws IOException
     */
    public String getQuerySql(String sqlName) throws IOException {
        return getSQLStr(sqlName, null, null);
    }

    private String getSQLStr(String sqlName, String[] queryFields, String[] orderBy) throws IOException {
        ClassPathResource resource = new ClassPathResource("sql/" + sqlName);
        InputStream dbAsStream = resource.getInputStream();
        StringBuilder sb = new StringBuilder();
        try (BufferedReader br = new BufferedReader(new InputStreamReader(dbAsStream))) {
            while (br.ready()) {
                sb.append(br.readLine());
            }
        }

        String sql = sb.toString();

        if (StringUtils.contains(sql, QUERY_FIELD) && queryFields != null && queryFields.length > 0) {
            sql = replaceField(sql, QUERY_FIELD, queryFields);
        }

        if ((StringUtils.contains(sql, "order by") || StringUtils.contains(sql, "ORDER BY")) && orderBy != null && orderBy.length > 0) {
            sql = replaceField(sql, ORDER_BY_FIELD, orderBy);
        }

        return sql;
    }

    /**
     * 組動態查詢條件SQL
     * @param sql
     * @param sqlMap
     */
    private String getQuerySql(String sql, Map<String, Object> sqlMap) {

        String[] str = StringUtils.substringsBetween(sql, "[", "]");
        if (str == null) {
            return sql;
        }

        Pattern pattern = Pattern.compile("\\:(\\S*)");

        List<String> strList = Arrays.asList(str);
        List<String> getStrList = new ArrayList<>();
        Set<String> keySet = sqlMap.keySet();
        for (String s : strList) {
            Matcher matcher = pattern.matcher(s);
            List<String> subStrList = new ArrayList<>();
            while (matcher.find()) {
                subStrList.add(matcher.group(0).replace(":", ""));
            }
            int subStrListSize = subStrList.size();
            if (subStrListSize == 0 || !keySet.containsAll(subStrList)) {
                continue;
            }

            getStrList.add(s);

        }
        strList = new ArrayList<>(strList);
        strList.removeAll(getStrList);

        for (String s : strList) {
            sql = StringUtils.replace(sql, s, "");
        }
        sql = sql.replace("[", "").replace("]", "");

        return sql;
    }

    /**
     * 替換欄位
     * @param sql
     * @return
     */
    private String replaceField(String sql, String replaceField, String[] orderBy) {

        StringBuilder sb = new StringBuilder();
        for (String field : orderBy) {
            sb.append(field).append(',');
        }
        String orderByStr = StringUtils.removeEnd(sb.toString(), ",");

        return sql.replace(replaceField, orderByStr);
    }
```
<br/>

## 參考

